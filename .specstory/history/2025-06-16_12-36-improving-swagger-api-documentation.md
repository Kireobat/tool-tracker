<!-- Generated by SpecStory -->

# Improving Swagger API Documentation (2025-06-16 14:36:23)

_**User**_

@workspace how should I document my api in swagger so it is easily understandable?

---

_**Assistant**_

Based on your codebase, here's how to improve your Swagger documentation to make it easily understandable:

## 1. Add detailed operation descriptions

````kotlin
@PostMapping("/tools/register")
@PreAuthorize("hasRole('EMPLOYEE')")
@Operation(
    summary = "Register a new tool",
    description = "Creates a new tool in the system. Only employees can register tools.",
    responses = [
        ApiResponse(responseCode = "200", description = "Tool successfully registered"),
        ApiResponse(responseCode = "400", description = "Invalid tool data provided"),
        ApiResponse(responseCode = "403", description = "Access denied - requires EMPLOYEE role"),
        ApiResponse(responseCode = "500", description = "Internal server error")
    ]
)
@SecurityRequirement(name = "basicAuth")
fun registerTool(@RequestBody registerToolDto: RegisterToolDto): ResponseEntity<ToolDto> {
    return ResponseEntity.ok(toolService.registerTool(registerToolDto).toToolDto())
}
````

## 2. Document path parameters and query parameters

````kotlin
@GetMapping("/tools/{id}")
@Operation(
    summary = "Get tool by ID",
    description = "Retrieves a specific tool by its ID. Non-employees can only view AVAILABLE tools."
)
fun getTool(
    @Parameter(description = "Unique identifier of the tool", example = "1")
    @PathVariable id: Int
): ResponseEntity<ToolDto> {
    // ...existing code...
}

@GetMapping("/tools")
@Operation(
    summary = "Search tools",
    description = "Search and filter tools with pagination. Non-employees can only see AVAILABLE tools."
)
fun getTools(
    @ParameterObject @PageableDefault(size = DEFAULT_PAGE_SIZE_INT, sort = [DEFAULT_SORT_NO_DIRECTION]) pageable: Pageable,
    @Parameter(description = "Filter by tool name (partial match)", example = "Drill")
    @RequestParam name: String?,
    @Parameter(description = "Filter by serial number (partial match)", example = "SN123")
    @RequestParam serial: String?,
    @Parameter(description = "Filter by tool type ID", example = "1")
    @RequestParam toolTypeId: Int?,
    @Parameter(description = "Filter by tool status (employees only)", example = "AVAILABLE")
    @RequestParam status: ToolStatusEnum?
): ResponseEntity<ToolTrackerPageDto<ToolDto>> {
    // ...existing code...
}
````

## 3. Add comprehensive OpenAPI configuration

````kotlin
@Configuration
@OpenAPIDefinition(
    info = Info(
        title = "Tool Tracker API",
        version = "v1.0",
        description = """
            Backend REST API service for managing tools, lending agreements, and damage reports.
            
            ## Authentication
            Most endpoints require authentication. Use the `/api/v1/user/login` endpoint first or use Basic Auth.
            
            ## Roles
            - **USER**: Basic user access
            - **EMPLOYEE**: Can manage tools, lending agreements, and damage reports
            - **ADMIN**: Full system access
            
            ## Tool Status
            - **AVAILABLE**: Tool is ready for lending
            - **UNAVAILABLE**: Tool is not available (visible to employees only)
            - **SERVICE**: Tool is under maintenance (visible to employees only)
        """,
        contact = Contact(name = "Tool Tracker Support"),
        license = License(name = "MIT")
    ),
    servers = [
        Server(url = "http://localhost:8080/tool-tracker", description = "Local development"),
        Server(url = "https://api.kireobat.eu/tool-tracker", description = "Production")
    ]
)
@SecurityScheme(
    name = "basicAuth",
    type = SecuritySchemeType.HTTP,
    scheme = "basic",
    description = "Enter your email and password"
)
class OpenApiConfig {
    
    @Bean
    fun customOpenAPI(): OpenAPI {
        return OpenAPI()
            .addSecurityItem(SecurityRequirement().addList("basicAuth"))
    }
}
````

## 4. Document your DTOs with examples

````kotlin
data class RegisterToolDto(
    @Schema(description = "Tool name", example = "Electric Drill", required = true)
    val name: String,
    
    @Schema(description = "Serial number", example = "SN123456789", required = true)
    val serial: String,
    
    @Schema(description = "Tool type ID", example = "1", required = true)
    val type: Int,
    
    @Schema(
        description = "Tool status", 
        example = "AVAILABLE",
        allowableValues = ["AVAILABLE", "UNAVAILABLE", "SERVICE"],
        defaultValue = "AVAILABLE"
    )
    val status: ToolStatusEnum? = null
)
````

## 5. Add meaningful tags and organize endpoints

````kotlin
@Tag(name = "Tools", description = "Tool management operations")
class ToolController(
    // ...existing code...
)

@Tag(name = "Authentication", description = "User authentication and authorization")
class UserController(
    // ...existing code...
)

@Tag(name = "Lending", description = "Tool lending and return operations")
class LendingAgreementController(
    // ...existing code...
)
````

## 6. Document error responses consistently

````kotlin
@ApiResponses(value = [
    ApiResponse(responseCode = "200", description = "Operation successful"),
    ApiResponse(
        responseCode = "400", 
        description = "Bad request - validation errors",
        content = [Content(
            mediaType = "application/json",
            schema = Schema(implementation = ToolTrackerResponseDto::class),
            examples = [ExampleObject(
                name = "Validation Error",
                value = """
                {
                  "success": false,
                  "timestamp": "2024-01-01T12:00:00Z",
                  "status": "BAD_REQUEST",
                  "message": "Invalid tool status. Status must be one of: AVAILABLE, UNAVAILABLE, SERVICE"
                }
                """
            )]
        )]
    ),
    ApiResponse(
        responseCode = "403", 
        description = "Access denied - insufficient permissions",
        content = [Content(schema = Schema(implementation = ToolTrackerResponseDto::class))]
    )
])
````

Don't forget to add the required imports:

````kotlin
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.media.ExampleObject
import io.swagger.v3.oas.annotations.responses.ApiResponses
````

This will make your API documentation much clearer and more professional, helping users understand:
- What each endpoint does
- What parameters are required
- What responses to expect
- How authentication works
- What the different roles can access

---

