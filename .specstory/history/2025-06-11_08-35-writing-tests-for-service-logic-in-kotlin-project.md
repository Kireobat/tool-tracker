<!-- Generated by SpecStory -->

# Writing tests for service logic in Kotlin project (2025-06-11 10:35:46)

_**User**_

@workspace Hey can you write some basic tests for the logic in the Service files in this project? I want test to both reading and writing data.

---

_**Assistant**_

Looking at your service files, I'll create comprehensive tests for the main service classes. Here are the test files that cover both reading and writing operations:

````kotlin
package eu.kireobat.tooltracker.service

import eu.kireobat.tooltracker.TestContainerConfiguration
import eu.kireobat.tooltracker.api.dto.inbound.LoginDto
import eu.kireobat.tooltracker.api.dto.inbound.RegisterUserDto
import eu.kireobat.tooltracker.persistence.entity.RoleEntity
import eu.kireobat.tooltracker.persistence.entity.UserEntity
import eu.kireobat.tooltracker.persistence.repository.RoleRepository
import eu.kireobat.tooltracker.persistence.repository.UserRepository
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.http.HttpStatus
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

@SpringBootTest
@Transactional
class UserServiceTest : TestContainerConfiguration() {

    @Autowired
    private lateinit var userService: UserService

    @Autowired
    private lateinit var userRepository: UserRepository

    @Autowired
    private lateinit var roleRepository: RoleRepository

    @Autowired
    private lateinit var passwordEncoder: PasswordEncoder

    private lateinit var defaultRole: RoleEntity

    @BeforeEach
    fun setup() {
        SecurityContextHolder.clearContext()
        userRepository.deleteAll()
        
        // Create default USER role
        defaultRole = roleRepository.save(RoleEntity(
            name = "USER",
            createdBy = 1
        ))
    }

    @Test
    fun `should register user successfully`() {
        val registerDto = RegisterUserDto(
            name = "Test User",
            email = "test@example.com",
            password = "password123"
        )

        val result = userService.registerUserByPassword(registerDto, null)

        assertNotNull(result)
        assertEquals("Test User", result.name)
        assertEquals("test@example.com", result.email)
        assertTrue(passwordEncoder.matches("password123", result.passwordHash))
        
        // Verify user exists in database
        val savedUser = userRepository.findByEmail("test@example.com")
        assertTrue(savedUser.isPresent)
    }

    @Test
    fun `should throw exception when registering duplicate email`() {
        val registerDto = RegisterUserDto(
            name = "Test User",
            email = "test@example.com",
            password = "password123"
        )

        // Register first user
        userService.registerUserByPassword(registerDto, null)

        // Try to register with same email
        val exception = assertThrows<ResponseStatusException> {
            userService.registerUserByPassword(registerDto, null)
        }

        assertEquals(HttpStatus.BAD_REQUEST, exception.statusCode)
        assertTrue(exception.reason!!.contains("email is already registered"))
    }

    @Test
    fun `should find user by email`() {
        val registerDto = RegisterUserDto(
            name = "Test User",
            email = "test@example.com",
            password = "password123"
        )

        userService.registerUserByPassword(registerDto, null)

        val result = userService.findByEmail("test@example.com")

        assertTrue(result.isPresent)
        assertEquals("test@example.com", result.get().email)
    }

    @Test
    fun `should validate login successfully`() {
        val registerDto = RegisterUserDto(
            name = "Test User",
            email = "test@example.com",
            password = "password123"
        )

        userService.registerUserByPassword(registerDto, null)

        val loginDto = LoginDto(
            email = "test@example.com",
            password = "password123"
        )

        val result = userService.validateLogin(loginDto)

        assertNotNull(result)
        assertEquals("test@example.com", result.email)
    }

    @Test
    fun `should throw exception for invalid login credentials`() {
        val registerDto = RegisterUserDto(
            name = "Test User",
            email = "test@example.com",
            password = "password123"
        )

        userService.registerUserByPassword(registerDto, null)

        val loginDto = LoginDto(
            email = "test@example.com",
            password = "wrongpassword"
        )

        val exception = assertThrows<ResponseStatusException> {
            userService.validateLogin(loginDto)
        }

        assertEquals(HttpStatus.BAD_REQUEST, exception.statusCode)
        assertTrue(exception.reason!!.contains("Invalid email or password"))
    }

    @Test
    fun `should find user by id`() {
        val registerDto = RegisterUserDto(
            name = "Test User",
            email = "test@example.com",
            password = "password123"
        )

        val user = userService.registerUserByPassword(registerDto, null)

        val result = userService.findById(user.id)

        assertTrue(result.isPresent)
        assertEquals(user.id, result.get().id)
    }
}
````

````kotlin
package eu.kireobat.tooltracker.service

import eu.kireobat.tooltracker.TestContainerConfiguration
import eu.kireobat.tooltracker.api.dto.inbound.RegisterToolDto
import eu.kireobat.tooltracker.common.enums.ToolStatusEnum
import eu.kireobat.tooltracker.persistence.entity.RoleEntity
import eu.kireobat.tooltracker.persistence.entity.ToolEntity
import eu.kireobat.tooltracker.persistence.entity.ToolTypeEntity
import eu.kireobat.tooltracker.persistence.entity.UserEntity
import eu.kireobat.tooltracker.persistence.repository.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.data.domain.PageRequest
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.transaction.annotation.Transactional
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

@SpringBootTest
@Transactional
class ToolServiceTest : TestContainerConfiguration() {

    @Autowired
    private lateinit var toolService: ToolService

    @Autowired
    private lateinit var toolRepository: ToolRepository

    @Autowired
    private lateinit var toolTypeRepository: ToolTypeRepository

    @Autowired
    private lateinit var userRepository: UserRepository

    @Autowired
    private lateinit var roleRepository: RoleRepository

    @Autowired
    private lateinit var passwordEncoder: PasswordEncoder

    private lateinit var testUser: UserEntity
    private lateinit var testToolType: ToolTypeEntity

    @BeforeEach
    fun setup() {
        SecurityContextHolder.clearContext()
        toolRepository.deleteAll()
        toolTypeRepository.deleteAll()
        userRepository.deleteAll()

        // Create test role
        val role = roleRepository.save(RoleEntity(
            name = "USER",
            createdBy = 1
        ))

        // Create test user
        testUser = userRepository.save(UserEntity(
            name = "Test User",
            email = "test@example.com",
            passwordHash = passwordEncoder.encode("password"),
            createdBy = 1
        ))

        // Create test tool type
        testToolType = toolTypeRepository.save(ToolTypeEntity(
            name = "Hammer",
            createdBy = testUser
        ))

        // Set authentication context
        val auth = UsernamePasswordAuthenticationToken(
            testUser.email,
            "password",
            listOf(SimpleGrantedAuthority("USER"))
        )
        SecurityContextHolder.getContext().authentication = auth
    }

    @Test
    fun `should register tool successfully`() {
        val registerDto = RegisterToolDto(
            name = "Test Hammer",
            serial = "TH001",
            toolTypeId = testToolType.id
        )

        val result = toolService.registerTool(registerDto)

        assertNotNull(result)
        assertEquals("Test Hammer", result.name)
        assertEquals("TH001", result.serial)
        assertEquals(ToolStatusEnum.AVAILABLE, result.status)
        assertEquals(testToolType.id, result.type.id)
        assertEquals(testUser.id, result.createdBy.id)
    }

    @Test
    fun `should find tool by id`() {
        val tool = toolRepository.save(ToolEntity(
            name = "Test Tool",
            serial = "TT001",
            status = ToolStatusEnum.AVAILABLE,
            type = testToolType,
            createdBy = testUser
        ))

        val result = toolService.findById(tool.id)

        assertTrue(result.isPresent)
        assertEquals(tool.id, result.get().id)
        assertEquals("Test Tool", result.get().name)
    }

    @Test
    fun `should find tools with filters`() {
        // Create test tools
        val tool1 = toolRepository.save(ToolEntity(
            name = "Electric Drill",
            serial = "ED001",
            status = ToolStatusEnum.AVAILABLE,
            type = testToolType,
            createdBy = testUser
        ))

        val tool2 = toolRepository.save(ToolEntity(
            name = "Manual Drill",
            serial = "MD001",
            status = ToolStatusEnum.BORROWED,
            type = testToolType,
            createdBy = testUser
        ))

        val pageable = PageRequest.of(0, 10)

        // Test name filter
        val resultByName = toolService.findTools(
            pageable = pageable,
            name = "Electric",
            serial = null,
            toolTypeId = null,
            status = null
        )

        assertEquals(1, resultByName.content.size)
        assertEquals("Electric Drill", resultByName.content[0].name)

        // Test status filter
        val resultByStatus = toolService.findTools(
            pageable = pageable,
            name = null,
            serial = null,
            toolTypeId = null,
            status = ToolStatusEnum.AVAILABLE
        )

        assertEquals(1, resultByStatus.content.size)
        assertEquals(ToolStatusEnum.AVAILABLE, resultByStatus.content[0].status)
    }

    @Test
    fun `should find all tools without filters`() {
        // Create multiple test tools
        repeat(3) { index ->
            toolRepository.save(ToolEntity(
                name = "Tool $index",
                serial = "T00$index",
                status = ToolStatusEnum.AVAILABLE,
                type = testToolType,
                createdBy = testUser
            ))
        }

        val pageable = PageRequest.of(0, 10)
        val result = toolService.findTools(
            pageable = pageable,
            name = null,
            serial = null,
            toolTypeId = null,
            status = null
        )

        assertEquals(3, result.content.size)
        assertTrue(result.content.all { it.type == testToolType.name })
    }
}
````

````kotlin
package eu.kireobat.tooltracker.service

import eu.kireobat.tooltracker.TestContainerConfiguration
import eu.kireobat.tooltracker.persistence.entity.RoleEntity
import eu.kireobat.tooltracker.persistence.entity.ToolTypeEntity
import eu.kireobat.tooltracker.persistence.entity.UserEntity
import eu.kireobat.tooltracker.persistence.repository.RoleRepository
import eu.kireobat.tooltracker.persistence.repository.ToolTypeRepository
import eu.kireobat.tooltracker.persistence.repository.UserRepository
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.data.domain.PageRequest
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.transaction.annotation.Transactional
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

@SpringBootTest
@Transactional
class ToolTypeServiceTest : TestContainerConfiguration() {

    @Autowired
    private lateinit var toolTypeService: ToolTypeService

    @Autowired
    private lateinit var toolTypeRepository: ToolTypeRepository

    @Autowired
    private lateinit var userRepository: UserRepository

    @Autowired
    private lateinit var roleRepository: RoleRepository

    @Autowired
    private lateinit var passwordEncoder: PasswordEncoder

    private lateinit var testUser: UserEntity

    @BeforeEach
    fun setup() {
        SecurityContextHolder.clearContext()
        toolTypeRepository.deleteAll()
        userRepository.deleteAll()

        // Create test role
        val role = roleRepository.save(RoleEntity(
            name = "USER",
            createdBy = 1
        ))

        // Create test user
        testUser = userRepository.save(UserEntity(
            name = "Test User",
            email = "test@example.com",
            passwordHash = passwordEncoder.encode("password"),
            createdBy = 1
        ))

        // Set authentication context
        val auth = UsernamePasswordAuthenticationToken(
            testUser.email,
            "password",
            listOf(SimpleGrantedAuthority("USER"))
        )
        SecurityContextHolder.getContext().authentication = auth
    }

    @Test
    fun `should create tool type successfully`() {
        val result = toolTypeService.create("Hammer")

        assertNotNull(result)
        assertEquals("Hammer", result.name)
        assertEquals(testUser.id, result.createdBy.id)

        // Verify it's saved in database
        val saved = toolTypeRepository.findById(result.id)
        assertTrue(saved.isPresent)
        assertEquals("Hammer", saved.get().name)
    }

    @Test
    fun `should find tool type by id`() {
        val toolType = toolTypeRepository.save(ToolTypeEntity(
            name = "Screwdriver",
            createdBy = testUser
        ))

        val result = toolTypeService.findById(toolType.id)

        assertTrue(result.isPresent)
        assertEquals(toolType.id, result.get().id)
        assertEquals("Screwdriver", result.get().name)
    }

    @Test
    fun `should find tool types with name filter`() {
        // Create test tool types
        toolTypeRepository.save(ToolTypeEntity(name = "Electric Drill", createdBy = testUser))
        toolTypeRepository.save(ToolTypeEntity(name = "Manual Drill", createdBy = testUser))
        toolTypeRepository.save(ToolTypeEntity(name = "Hammer", createdBy = testUser))

        val pageable = PageRequest.of(0, 10)

        // Test with name filter
        val result = toolTypeService.findToolTypes(pageable, "Drill")

        assertEquals(2, result.content.size)
        assertTrue(result.content.all { it.name.contains("Drill") })
    }

    @Test
    fun `should find all tool types without filter`() {
        // Create test tool types
        val toolTypes = listOf("Hammer", "Screwdriver", "Drill")
        toolTypes.forEach { name ->
            toolTypeRepository.save(ToolTypeEntity(name = name, createdBy = testUser))
        }

        val pageable = PageRequest.of(0, 10)
        val result = toolTypeService.findToolTypes(pageable, null)

        assertEquals(3, result.content.size)
        assertEquals(toolTypes.sorted(), result.content.map { it.name }.sorted())
    }
}
````

````kotlin
package eu.kireobat.tooltracker.service

import eu.kireobat.tooltracker.TestContainerConfiguration
import eu.kireobat.tooltracker.api.dto.inbound.CreateLendingAgreementDto
import eu.kireobat.tooltracker.common.enums.ToolStatusEnum
import eu.kireobat.tooltracker.persistence.entity.*
import eu.kireobat.tooltracker.persistence.repository.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.data.domain.PageRequest
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.transaction.annotation.Transactional
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

@SpringBootTest
@Transactional
class LendingAgreementServiceTest : TestContainerConfiguration() {

    @Autowired
    private lateinit var lendingAgreementService: LendingAgreementService

    @Autowired
    private lateinit var lendingAgreementRepository: LendingAgreementRepository

    @Autowired
    private lateinit var userRepository: UserRepository

    @Autowired
    private lateinit var toolRepository: ToolRepository

    @Autowired
    private lateinit var toolTypeRepository: ToolTypeRepository

    @Autowired
    private lateinit var roleRepository: RoleRepository

    @Autowired
    private lateinit var passwordEncoder: PasswordEncoder

    private lateinit var testUser: UserEntity
    private lateinit var borrowerUser: UserEntity
    private lateinit var testTool: ToolEntity

    @BeforeEach
    fun setup() {
        SecurityContextHolder.clearContext()
        lendingAgreementRepository.deleteAll()
        toolRepository.deleteAll()
        toolTypeRepository.deleteAll()
        userRepository.deleteAll()

        // Create test role
        val role = roleRepository.save(RoleEntity(
            name = "USER",
            createdBy = 1
        ))

        // Create test users
        testUser = userRepository.save(UserEntity(
            name = "Lender User",
            email = "lender@example.com",
            passwordHash = passwordEncoder.encode("password"),
            createdBy = 1
        ))

        borrowerUser = userRepository.save(UserEntity(
            name = "Borrower User",
            email = "borrower@example.com",
            passwordHash = passwordEncoder.encode("password"),
            createdBy = 1
        ))

        // Create test tool type and tool
        val toolType = toolTypeRepository.save(ToolTypeEntity(
            name = "Hammer",
            createdBy = testUser
        ))

        testTool = toolRepository.save(ToolEntity(
            name = "Test Hammer",
            serial = "TH001",
            status = ToolStatusEnum.AVAILABLE,
            type = toolType,
            createdBy = testUser
        ))

        // Set authentication context
        val auth = UsernamePasswordAuthenticationToken(
            testUser.email,
            "password",
            listOf(SimpleGrantedAuthority("USER"))
        )
        SecurityContextHolder.getContext().authentication = auth
    }

    @Test
    fun `should create lending agreement successfully`() {
        val createDto = CreateLendingAgreementDto(
            borrowerId = borrowerUser.id,
            toolId = testTool.id
        )

        val result = lendingAgreementService.create(createDto)

        assertNotNull(result)
        assertEquals(borrowerUser.id, result.borrower.id)
        assertEquals(testTool.id, result.tool.id)
        assertEquals(testUser.id, result.createdBy.id)
        assertNotNull(result.lendingStartTime)
    }

    @Test
    fun `should find lending agreement by id`() {
        val agreement = lendingAgreementRepository.save(LendingAgreementEntity(
            borrower = borrowerUser,
            tool = testTool,
            createdBy = testUser
        ))

        val result = lendingAgreementService.findById(agreement.id)

        assertTrue(result.isPresent)
        assertEquals(agreement.id, result.get().id)
        assertEquals(borrowerUser.id, result.get().borrower.id)
    }

    @Test
    fun `should find agreements with filters`() {
        // Create test agreements
        val agreement1 = lendingAgreementRepository.save(LendingAgreementEntity(
            borrower = borrowerUser,
            tool = testTool,
            createdBy = testUser
        ))

        // Create another tool and agreement
        val toolType2 = toolTypeRepository.save(ToolTypeEntity(
            name = "Screwdriver",
            createdBy = testUser
        ))

        val tool2 = toolRepository.save(ToolEntity(
            name = "Test Screwdriver",
            serial = "TS001",
            status = ToolStatusEnum.AVAILABLE,
            type = toolType2,
            createdBy = testUser
        ))

        val agreement2 = lendingAgreementRepository.save(LendingAgreementEntity(
            borrower = borrowerUser,
            tool = tool2,
            createdBy = testUser
        ))

        val pageable = PageRequest.of(0, 10)

        // Test filter by tool ID
        val resultByTool = lendingAgreementService.findAgreements(
            pageable = pageable,
            toolId = testTool.id,
            borrowerId = null,
            lentAfter = null,
            lentBefore = null
        )

        assertEquals(1, resultByTool.content.size)
        assertEquals(testTool.id, resultByTool.content[0].toolId)

        // Test filter by borrower ID
        val resultByBorrower = lendingAgreementService.findAgreements(
            pageable = pageable,
            toolId = null,
            borrowerId = borrowerUser.id,
            lentAfter = null,
            lentBefore = null
        )

        assertEquals(2, resultByBorrower.content.size)
        assertTrue(resultByBorrower.content.all { it.borrowerId == borrowerUser.id })
    }
}
````

````kotlin
package eu.kireobat.tooltracker.service

import eu.kireobat.tooltracker.TestContainerConfiguration
import eu.kireobat.tooltracker.api.dto.inbound.CreateDamageReportDto
import eu.kireobat.tooltracker.common.enums.ToolStatusEnum
import eu.kireobat.tooltracker.persistence.entity.*
import eu.kireobat.tooltracker.persistence.repository.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.data.domain.PageRequest
import org.springframework.http.HttpStatus
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.server.ResponseStatusException
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

@SpringBootTest
@Transactional
class DamageReportServiceTest : TestContainerConfiguration() {

    @Autowired
    private lateinit var damageReportService: DamageReportService

    @Autowired
    private lateinit var damageReportRepository: DamageReportRepository

    @Autowired
    private lateinit var userRepository: UserRepository

    @Autowired
    private lateinit var toolRepository: ToolRepository

    @Autowired
    private lateinit var toolTypeRepository: ToolTypeRepository

    @Autowired
    private lateinit var lendingAgreementRepository: LendingAgreementRepository

    @Autowired
    private lateinit var roleRepository: RoleRepository

    @Autowired
    private lateinit var passwordEncoder: PasswordEncoder

    private lateinit var testUser: UserEntity
    private lateinit var testTool: ToolEntity
    private lateinit var testLendingAgreement: LendingAgreementEntity

    @BeforeEach
    fun setup() {
        SecurityContextHolder.clearContext()
        damageReportRepository.deleteAll()
        lendingAgreementRepository.deleteAll()
        toolRepository.deleteAll()
        toolTypeRepository.deleteAll()
        userRepository.deleteAll()

        // Create test role
        val role = roleRepository.save(RoleEntity(
            name = "USER",
            createdBy = 1
        ))

        // Create test user
        testUser = userRepository.save(UserEntity(
            name = "Test User",
            email = "test@example.com",
            passwordHash = passwordEncoder.encode("password"),
            createdBy = 1
        ))

        // Create test tool
        val toolType = toolTypeRepository.save(ToolTypeEntity(
            name = "Hammer",
            createdBy = testUser
        ))

        testTool = toolRepository.save(ToolEntity(
            name = "Test Hammer",
            serial = "TH001",
            status = ToolStatusEnum.AVAILABLE,
            type = toolType,
            createdBy = testUser
        ))

        // Create test lending agreement
        testLendingAgreement = lendingAgreementRepository.save(LendingAgreementEntity(
            borrower = testUser,
            tool = testTool,
            createdBy = testUser
        ))

        // Set authentication context
        val auth = UsernamePasswordAuthenticationToken(
            testUser.email,
            "password",
            listOf(SimpleGrantedAuthority("USER"))
        )
        SecurityContextHolder.getContext().authentication = auth
    }

    @Test
    fun `should create damage report with tool ID`() {
        val createDto = CreateDamageReportDto(
            toolId = testTool.id,
            lendingAgreementId = null,
            description = "Hammer head is loose"
        )

        val result = damageReportService.create(createDto)

        assertNotNull(result)
        assertEquals(testTool.id, result.tool?.id)
        assertEquals("Hammer head is loose", result.description)
        assertEquals(testUser.id, result.createdBy.id)
    }

    @Test
    fun `should create damage report with lending agreement ID`() {
        val createDto = CreateDamageReportDto(
            toolId = null,
            lendingAgreementId = testLendingAgreement.id,
            description = "Tool damaged during lending"
        )

        val result = damageReportService.create(createDto)

        assertNotNull(result)
        assertEquals(testLendingAgreement.id, result.lendingAgreement?.id)
        assertEquals("Tool damaged during lending", result.description)
        assertEquals(testUser.id, result.createdBy.id)
    }

    @Test
    fun `should throw exception when both tool ID and lending agreement ID are null`() {
        val createDto = CreateDamageReportDto(
            toolId = null,
            lendingAgreementId = null,
            description = "Some damage"
        )

        val exception = assertThrows<ResponseStatusException> {
            damageReportService.create(createDto)
        }

        assertEquals(HttpStatus.BAD_REQUEST, exception.statusCode)
        assertTrue(exception.reason!!.contains("lendingAgreementId and toolId can not be null at the same time"))
    }

    @Test
    fun `should find damage report by id`() {
        val report = damageReportRepository.save(DamageReportEntity(
            tool = testTool,
            lendingAgreement = null,
            description = "Test damage",
            createdBy = testUser
        ))

        val result = damageReportService.findById(report.id)

        assertTrue(result.isPresent)
        assertEquals(report.id, result.get().id)
        assertEquals("Test damage", result.get().description)
    }

    @Test
    fun `should find reports with filters`() {
        // Create test reports
        val report1 = damageReportRepository.save(DamageReportEntity(
            tool = testTool,
            lendingAgreement = null,
            description = "Tool damage",
            createdBy = testUser
        ))

        val report2 = damageReportRepository.save(DamageReportEntity(
            tool = null,
            lendingAgreement = testLendingAgreement,
            description = "Agreement damage",
            createdBy = testUser
        ))

        val pageable = PageRequest.of(0, 10)

        // Test filter by tool ID
        val resultByTool = damageReportService.findReports(
            pageable = pageable,
            lendingAgreementId = null,
            toolId = testTool.id
        )

        assertEquals(1, resultByTool.content.size)
        assertEquals(testTool.id, resultByTool.content[0].toolId)

        // Test filter by lending agreement ID
        val resultByAgreement = damageReportService.findReports(
            pageable = pageable,
            lendingAgreementId = testLendingAgreement.id,
            toolId = null
        )

        assertEquals(1, resultByAgreement.content.size)
        assertEquals(testLendingAgreement.id, resultByAgreement.content[0].lendingAgreementId)
    }
}
````

These tests cover:

1. **UserService**: Registration, login validation, finding users by email/ID, duplicate email handling
2. **ToolService**: Tool registration, finding tools by ID, filtering tools by various criteria
3. **ToolTypeService**: Creating tool types, finding by ID, filtering by name
4. **LendingAgreementService**: Creating agreements, finding by ID, filtering by tool/borrower
5. **DamageReportService**: Creating reports with different parameters, validation, finding and filtering

Each test class:
- Extends `TestContainerConfiguration` for database testing
- Uses `@Transactional` for test isolation
- Sets up proper authentication context where needed
- Tests both successful operations and error cases
- Covers reading and writing operations as requested

The tests use the existing test infrastructure and follow Spring Boot testing best practices with proper setup/teardown and realistic test data.

---

