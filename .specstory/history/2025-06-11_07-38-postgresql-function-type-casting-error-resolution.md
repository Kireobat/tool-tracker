<!-- Generated by SpecStory -->

# PostgreSQL function type casting error resolution (2025-06-11 09:38:54)

_**User**_

ERROR: function lower(bytea) does not exist
  Hint: No function matches the given name and argument types. You might need to add explicit type casts.
  Position: 228
2025-06-11T09:38:39.222+02:00 ERROR 12092 --- [tool-tracker] [nio-8080-exec-1] e.k.t.a.e.GlobalControllerAdvice         : JDBC exception executing SQL [select te1_0.id,te1_0.created_by,te1_0.created_time,te1_0.modified_by,te1_0.modified_time,te1_0.name,te1_0.serial,te1_0.status,te1_0.type from tool_tracker.tools te1_0 where (? is null or lower(te1_0.name) like coalesce(('%'||lower(?)||'%'),'%') escape '') and (? is null or lower(te1_0.serial) like coalesce(('%'||lower(?)||'%'),'%') escape '') and (? is null or te1_0.type=?) and (? is null or te1_0.status=?) order by te1_0.id fetch first ? rows only] [ERROR: function lower(bytea) does not exist
  Hint: No function matches the given name and argument types. You might need to add explicit type casts.
  Position: 228] [n/a]; SQL [n/a]

---

_**Assistant**_

The error indicates that PostgreSQL is treating the parameters as `bytea` (binary data) instead of text/varchar. This happens because the parameters are being passed as null or have ambiguous types. You need to explicitly cast the parameters to text in your JPQL query.

Here's the fix:

````kotlin
// ...existing code...
@Repository
interface ToolRepository: JpaRepository<ToolEntity, Int> {
    @Query("select t from ToolEntity t " +
            "where " +
            "(:name is null or lower(cast(t.name as string)) like coalesce(concat('%', lower(cast(:name as string)), '%'), '%')) and " +
            "(:serial is null or lower(cast(t.serial as string)) like coalesce(concat('%', lower(cast(:serial as string)), '%'), '%')) and " +
            "(:toolTypeId is null or t.type.id = :toolTypeId) and " +
            "(:status is null or t.status = :status)")
    fun findAllWithFilter(
        pageable: Pageable,
        @Param("name") name: String?,
        @Param("serial") serial: String?,
        @Param("toolTypeId") toolTypeId: Int?,
        @Param("status") status: ToolStatusEnum?
    ): Page<ToolEntity>
}
// ...existing code...
````

If the above doesn't work with JPQL's `cast`, try using native SQL query instead:

````kotlin
// ...existing code...
@Repository
interface ToolRepository: JpaRepository<ToolEntity, Int> {
    @Query(value = "select * from tool_tracker.tools t " +
            "where " +
            "(:name is null or lower(t.name::text) like coalesce(concat('%', lower(:name::text), '%'), '%')) and " +
            "(:serial is null or lower(t.serial::text) like coalesce(concat('%', lower(:serial::text), '%'), '%')) and " +
            "(:toolTypeId is null or t.type = :toolTypeId) and " +
            "(:status is null or t.status = :status)",
            nativeQuery = true)
    fun findAllWithFilter(
        pageable: Pageable,
        @Param("name") name: String?,
        @Param("serial") serial: String?,
        @Param("toolTypeId") toolTypeId: Int?,
        @Param("status") status: String?
    ): Page<ToolEntity>
}
// ...existing code...
````

Note: If using native SQL, you'll need to change the `status` parameter type from `ToolStatusEnum?` to `String?` since native queries work with raw SQL types.

---

