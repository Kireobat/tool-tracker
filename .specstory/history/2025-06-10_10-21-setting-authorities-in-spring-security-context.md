<!-- Generated by SpecStory -->

# Setting authorities in Spring Security context (2025-06-10 12:21:32)

_**User**_

How can I set the authorities in SpringContextHolder.getContext().authentication?

---

_**Assistant**_

You can set authorities in Spring Security by creating a new `Authentication` object with the desired authorities. Here are a few approaches:

## Method 1: Using UsernamePasswordAuthenticationToken

````kotlin
import org.springframework.security.core.authority.SimpleGrantedAuthority

// ...existing code...
val authToken = UsernamePasswordAuthenticationToken(loginDto.email, loginDto.password)
val authentication = authenticationManager.authenticate(authToken)

// Create new authentication with additional authorities
val authorities = mutableListOf<SimpleGrantedAuthority>()
authorities.addAll(authentication.authorities.map { SimpleGrantedAuthority(it.authority) })
authorities.add(SimpleGrantedAuthority("ROLE_CUSTOM")) // Add custom authority

val newAuth = UsernamePasswordAuthenticationToken(
    authentication.principal,
    authentication.credentials,
    authorities
)

SecurityContextHolder.getContext().authentication = newAuth
// ...existing code...
````

## Method 2: Modify during authentication process

You can also set authorities by customizing your `UserDetailsService` implementation to return the appropriate authorities when loading user details.

## Method 3: Using PreAuthenticatedAuthenticationToken

````kotlin
import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken

val authorities = listOf(
    SimpleGrantedAuthority("ROLE_USER"),
    SimpleGrantedAuthority("ROLE_ADMIN")
)

val preAuthToken = PreAuthenticatedAuthenticationToken(
    authentication.principal,
    authentication.credentials,
    authorities
)

SecurityContextHolder.getContext().authentication = preAuthToken
````

The most common approach is Method 1, where you create a new `UsernamePasswordAuthenticationToken` with the existing principal and credentials but with your desired authorities collection.

---

_**User**_

Why doesn't "hasRole('USER')" allow users who according to /roles has the role "USER"?

---

_**Assistant**_

The issue is likely that Spring Security's `hasRole()` method expects roles to be prefixed with `ROLE_`, but it automatically adds this prefix when checking. So when you use `hasRole('USER')`, Spring Security actually looks for `ROLE_USER` in the authorities.

Looking at your code, you're getting roles from `userMapRoleService.getRoles(userEntity.id)`. The authorities returned by this service might not have the `ROLE_` prefix.

Here are two solutions:

## Solution 1: Use `hasAuthority()` instead of `hasRole()`

````kotlin
@GetMapping("/hasRole")
@PreAuthorize("hasAuthority('USER')")
fun getAdminStatus(): ResponseEntity<Boolean> {
    return ResponseEntity.ok(true)
}
````

## Solution 2: Ensure your UserMapRoleService returns roles with ROLE_ prefix

Make sure your `userMapRoleService.getRoles()` returns authorities like `ROLE_USER`, `ROLE_ADMIN`, etc. You can check what's actually being returned by looking at the `/roles` endpoint output.

## Debug: Check what authorities are actually set

Add some logging to see what authorities are being set:

````kotlin
val authToken = UsernamePasswordAuthenticationToken(loginDto.email, loginDto.password, userMapRoleService.getRoles(userEntity.id))
val authentication = authenticationManager.authenticate(authToken)

// Debug: Print authorities
println("Authorities: ${authentication.authorities.map { it.authority }}")

SecurityContextHolder.getContext().authentication = authentication
````

The most common cause is that your roles don't have the `ROLE_` prefix. Spring Security's `hasRole('USER')` specifically looks for `ROLE_USER`, while `hasAuthority('USER')` looks for exactly `USER`.

---

